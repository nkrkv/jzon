{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started with Jzon Jzon is a library for ReScript to encode and decode JSON data with type safety. Installation yarn add rescript-jzon Add \"rescript-jzon\" item to the dependencies key of bsconfig.json Quick start Imagine you have the following ReScript types to encode and decode: type style = { size: float, color: string, } type point = { x: float, y: float, z: float, style: option<style>, } First, define their codecs : module Codecs = { let style = Jzon.object2( // Function to encode original object to linear tuple ({size, color}) => (size, color), // Function to decode linear tuple back to object ((size, color)) => {size, color}->Ok, // Field names and codecs for the tuple elements Jzon.field(\"size\", Jzon.float), Jzon.field(\"color\", Jzon.string), ); // Similar codec for another record type let point = Jzon.object4( ({x, y, z, style}) => (x, y, z, style), ((x, y, z, style)) => {x, y, z, style}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), // ... supports default values Jzon.field(\"z\", Jzon.float)->Jzon.default(0.0), // ... may refer your other codecs Jzon.field(\"style\", style)->Jzon.optional, ) } Next, convert between the ReScript types and Js.Json.t with: let myPoint = { x: 1.0, y: 2.0, z: 3.0, style: Some({size: 4.0, color: \"#fd0\"}), } let json = myPoint->Jzon.encodeWith(Codecs.point) and back with: let myPoint = json->Jzon.decodeWith(Codecs.point) What\u2019s next Read How-to Guides to learn how to deal with typical scenarios See API Reference for the complete list of stuff provided by Jzon","title":"Getting Started"},{"location":"#getting-started-with-jzon","text":"Jzon is a library for ReScript to encode and decode JSON data with type safety.","title":"Getting Started with Jzon"},{"location":"#installation","text":"yarn add rescript-jzon Add \"rescript-jzon\" item to the dependencies key of bsconfig.json","title":"Installation"},{"location":"#quick-start","text":"Imagine you have the following ReScript types to encode and decode: type style = { size: float, color: string, } type point = { x: float, y: float, z: float, style: option<style>, } First, define their codecs : module Codecs = { let style = Jzon.object2( // Function to encode original object to linear tuple ({size, color}) => (size, color), // Function to decode linear tuple back to object ((size, color)) => {size, color}->Ok, // Field names and codecs for the tuple elements Jzon.field(\"size\", Jzon.float), Jzon.field(\"color\", Jzon.string), ); // Similar codec for another record type let point = Jzon.object4( ({x, y, z, style}) => (x, y, z, style), ((x, y, z, style)) => {x, y, z, style}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), // ... supports default values Jzon.field(\"z\", Jzon.float)->Jzon.default(0.0), // ... may refer your other codecs Jzon.field(\"style\", style)->Jzon.optional, ) } Next, convert between the ReScript types and Js.Json.t with: let myPoint = { x: 1.0, y: 2.0, z: 3.0, style: Some({size: 4.0, color: \"#fd0\"}), } let json = myPoint->Jzon.encodeWith(Codecs.point) and back with: let myPoint = json->Jzon.decodeWith(Codecs.point)","title":"Quick start"},{"location":"#whats-next","text":"Read How-to Guides to learn how to deal with typical scenarios See API Reference for the complete list of stuff provided by Jzon","title":"What\u2019s next"},{"location":"api/","text":"Jzon API Reference module Jzon Types type codec<'v> Defines a thing that can encode a value of type 'v to Js.Json.t and decode it back. You either use one of built-in codecs, compose own codec from others using adaptors, or define a custom one. type field<'v> Defines a field descriptor used to encode and decode an object field of type 'v . Used for describing object codecs. Decoding let decode: (codec<'v>, Js.Json.t) => result<'v, DecodingError.t> let decodeWith: (Js.Json.t, codec<'v>) => result<'v, DecodingError.t> let decodeString: (codec<'v>, string) => result<'v, DecodingError.t> let decodeStringWith: (string, codec<'v>) => result<'v, DecodingError.t> Decode payload given a codec. The functions never throw as long as custom codecs and object constructors do not throw. If you are in doubt which argument order to prefer, use data-first (i.e. decodeWith ) for the sake of consistency. Usage experience shows it fits long pipe -> chains -> nicely. Encoding let encode: (codec<'v>, 'v) => Js.Json.t let encodeWith: ('v, codec<'v>) => Js.Json.t let encodeString: (codec<'v>, 'v) => string let encodeStringWith: ('v, codec<'v>) => string Encodes a value with the given codec. The functions always succeed as long as custom codecs and object destructors do not throw. If you are in doubt which argument order to prefer, use data-first (i.e. encodeWith ) for the sake of consistency. Usage experience shows it fits long pipe -> chains -> nicely. Simple codecs let string: codec<string> let float: codec<float> let int: codec<int> let bool: codec<bool> let json: codec<Js.Json.t> Provide codecs for scalar JSON types. The json codec is effectively an identity codec that encodes Js.Json.t to itself and back without changes. Useful in cases when composing a custom codec for data having different schemas in different cases. The int codec is somewhat opinionated because the JSON standard does not define an integer value, only floating point numbers. The int encoding always succeeds but decoding fails with #UnexpectedJsonValue in several cases: The value contains fractional part (42 and 42.0 are OK, 42.5 is not) The value is out of -2^31..+2^31 range and thus cannot be represented with ReScript\u2019s int Array adapter let array: codec<'v> => codec<array<'v>> Using the given codec, makes a new codec for an array which uses that given codec to encode and decode array elements. Dict adapter let dict: codec<'v> => codec<Js.Dict.t<'v>> Using the given codec, makes a new codec for a dictionary. The dictionary uses that given codec to encode and decode the values. Keys are encoded and decoded as strings without any changes. Null adapters let nullable: codec<'v> => codec<option<'v>> Makes a codec accept the null JSON value by making its payload type option \u2019al. None is encoded as JSON null , Some(value) is encoded as plain value would be encoded. let nullAs: (codec<'v>, 'v) => codec<'v> Makes a codec accept the null JSON value while decoding by falling back to a predefined default value. The encoding process always outputs the real value even if it is equal to the default value. That is, nullAs never produces a JSON null value. Object codecs // NOTE: Not a real syntax. On practice use object1, object3, object13, etc., // depending on the number of fields let objectN: ( 'r => ('f1, 'f2, ..., 'fN), (('f1, 'f2, ..., 'fN)) => result<'r, DecodingError.t>, field<'f1>, field<'f2>, ... field<'fN>, ) => codec<'r> Makes an object codec that translates between a JSON object and a ReScript object (record, tuple, custom opaque, whatever). The function takes arguments in the following order: destructor : a function which takes the ReScript object and converts it to the tuple with the order and element types dictated by the field descriptors constructor : a function which takes a tuple with the order and element types dictated by the field descriptors, and converts the tuple to the ReScript object. The function may return an Error(DecodingError.t) to fail the whole decoding process. N field descriptors : N arguments which define the object keys and values. The codecs are currently available for N from 1 to 25. If you have an object with more fields, it is likely you have some patterns in it that are better served by a custom codec. let field: (string, codec<'v>) => field<'v> Makes a descriptor for an object field with the given key/name, using the codec provided. let self: field<Js.Json.t> Makes a descriptor referring to the whole object being processed. Useful if the object shape depends on some factors, like a variant value. let optional: field<'v> => field<option<'v>> Makes the given field optional. The field will be decoded to the None value if the given field key is missing in the JSON object or if the key is there but its value is null . While encoding, if the ReScript value is None the given field key will be omitted from the resulting JSON. let default: (field<'v>, 'v) => field<'v> Makes the given field optional. The field will be decoded to the default fallback value provided if the given field key is missing in the JSON object or if the key is there but its value is null . While encoding, the resulting JSON always includes the key, even if the value is equal to the default. Custom codecs let custom: ('v => Js.Json.t, Js.Json.t => result<'v, DecodingError.t>) => codec<'v> Creates a custom codec. Use this to integrate with existing codebase which does not relies on Jzon or when you have a quirky JSON representation which is hard or impossible to express by composing other codecs and adapters. The first argument is a function to encode the ReScript value into JSON. And the second argument is a function to decode JSON into the ReScript value. Decoding utilities let asObject: Js.Json.t => result<Js.Dict.t<Js.Json.t>, DecodingError.t> Reinterprets a JSON object as a dictionary of JSON objects. Returns Error(#UnexpectedJsonType(...)) if the argument is not an object (e.g., it is number or null). module Jzon.DecodingError type locationComponent = Field(string) | Index(int) type location = array<locationComponent> type t = [ | #SyntaxError(string) | #MissingField(location, string /* key */) | #UnexpectedJsonType(location, string /* expected */, Js.Json.t /* actual */) | #UnexpectedJsonValue(location, string /* actual */) ] An error type that used extensively as a failed result payload while decoding. let toString: t => string Formats the error as a string suitable for logging or showing to a user. let prependLocation: (t, locationComponent) => t Transforms the error by prepending a location component. Other details are kept intact. Use this function to rectify the error location while implementing custom codecs. Particularly, when you drill-down a Js.Json.t object manually and mix this with decoding through other codecs which know nothing about your drill-down.","title":"API Reference"},{"location":"api/#jzon-api-reference","text":"","title":"Jzon API Reference"},{"location":"api/#module-jzon","text":"","title":"module Jzon"},{"location":"api/#types","text":"type codec<'v> Defines a thing that can encode a value of type 'v to Js.Json.t and decode it back. You either use one of built-in codecs, compose own codec from others using adaptors, or define a custom one. type field<'v> Defines a field descriptor used to encode and decode an object field of type 'v . Used for describing object codecs.","title":"Types"},{"location":"api/#decoding","text":"let decode: (codec<'v>, Js.Json.t) => result<'v, DecodingError.t> let decodeWith: (Js.Json.t, codec<'v>) => result<'v, DecodingError.t> let decodeString: (codec<'v>, string) => result<'v, DecodingError.t> let decodeStringWith: (string, codec<'v>) => result<'v, DecodingError.t> Decode payload given a codec. The functions never throw as long as custom codecs and object constructors do not throw. If you are in doubt which argument order to prefer, use data-first (i.e. decodeWith ) for the sake of consistency. Usage experience shows it fits long pipe -> chains -> nicely.","title":"Decoding"},{"location":"api/#encoding","text":"let encode: (codec<'v>, 'v) => Js.Json.t let encodeWith: ('v, codec<'v>) => Js.Json.t let encodeString: (codec<'v>, 'v) => string let encodeStringWith: ('v, codec<'v>) => string Encodes a value with the given codec. The functions always succeed as long as custom codecs and object destructors do not throw. If you are in doubt which argument order to prefer, use data-first (i.e. encodeWith ) for the sake of consistency. Usage experience shows it fits long pipe -> chains -> nicely.","title":"Encoding"},{"location":"api/#simple-codecs","text":"let string: codec<string> let float: codec<float> let int: codec<int> let bool: codec<bool> let json: codec<Js.Json.t> Provide codecs for scalar JSON types. The json codec is effectively an identity codec that encodes Js.Json.t to itself and back without changes. Useful in cases when composing a custom codec for data having different schemas in different cases. The int codec is somewhat opinionated because the JSON standard does not define an integer value, only floating point numbers. The int encoding always succeeds but decoding fails with #UnexpectedJsonValue in several cases: The value contains fractional part (42 and 42.0 are OK, 42.5 is not) The value is out of -2^31..+2^31 range and thus cannot be represented with ReScript\u2019s int","title":"Simple codecs"},{"location":"api/#array-adapter","text":"let array: codec<'v> => codec<array<'v>> Using the given codec, makes a new codec for an array which uses that given codec to encode and decode array elements.","title":"Array adapter"},{"location":"api/#dict-adapter","text":"let dict: codec<'v> => codec<Js.Dict.t<'v>> Using the given codec, makes a new codec for a dictionary. The dictionary uses that given codec to encode and decode the values. Keys are encoded and decoded as strings without any changes.","title":"Dict adapter"},{"location":"api/#null-adapters","text":"let nullable: codec<'v> => codec<option<'v>> Makes a codec accept the null JSON value by making its payload type option \u2019al. None is encoded as JSON null , Some(value) is encoded as plain value would be encoded. let nullAs: (codec<'v>, 'v) => codec<'v> Makes a codec accept the null JSON value while decoding by falling back to a predefined default value. The encoding process always outputs the real value even if it is equal to the default value. That is, nullAs never produces a JSON null value.","title":"Null adapters"},{"location":"api/#object-codecs","text":"// NOTE: Not a real syntax. On practice use object1, object3, object13, etc., // depending on the number of fields let objectN: ( 'r => ('f1, 'f2, ..., 'fN), (('f1, 'f2, ..., 'fN)) => result<'r, DecodingError.t>, field<'f1>, field<'f2>, ... field<'fN>, ) => codec<'r> Makes an object codec that translates between a JSON object and a ReScript object (record, tuple, custom opaque, whatever). The function takes arguments in the following order: destructor : a function which takes the ReScript object and converts it to the tuple with the order and element types dictated by the field descriptors constructor : a function which takes a tuple with the order and element types dictated by the field descriptors, and converts the tuple to the ReScript object. The function may return an Error(DecodingError.t) to fail the whole decoding process. N field descriptors : N arguments which define the object keys and values. The codecs are currently available for N from 1 to 25. If you have an object with more fields, it is likely you have some patterns in it that are better served by a custom codec. let field: (string, codec<'v>) => field<'v> Makes a descriptor for an object field with the given key/name, using the codec provided. let self: field<Js.Json.t> Makes a descriptor referring to the whole object being processed. Useful if the object shape depends on some factors, like a variant value. let optional: field<'v> => field<option<'v>> Makes the given field optional. The field will be decoded to the None value if the given field key is missing in the JSON object or if the key is there but its value is null . While encoding, if the ReScript value is None the given field key will be omitted from the resulting JSON. let default: (field<'v>, 'v) => field<'v> Makes the given field optional. The field will be decoded to the default fallback value provided if the given field key is missing in the JSON object or if the key is there but its value is null . While encoding, the resulting JSON always includes the key, even if the value is equal to the default.","title":"Object codecs"},{"location":"api/#custom-codecs","text":"let custom: ('v => Js.Json.t, Js.Json.t => result<'v, DecodingError.t>) => codec<'v> Creates a custom codec. Use this to integrate with existing codebase which does not relies on Jzon or when you have a quirky JSON representation which is hard or impossible to express by composing other codecs and adapters. The first argument is a function to encode the ReScript value into JSON. And the second argument is a function to decode JSON into the ReScript value.","title":"Custom codecs"},{"location":"api/#decoding-utilities","text":"let asObject: Js.Json.t => result<Js.Dict.t<Js.Json.t>, DecodingError.t> Reinterprets a JSON object as a dictionary of JSON objects. Returns Error(#UnexpectedJsonType(...)) if the argument is not an object (e.g., it is number or null).","title":"Decoding utilities"},{"location":"api/#module-jzondecodingerror","text":"type locationComponent = Field(string) | Index(int) type location = array<locationComponent> type t = [ | #SyntaxError(string) | #MissingField(location, string /* key */) | #UnexpectedJsonType(location, string /* expected */, Js.Json.t /* actual */) | #UnexpectedJsonValue(location, string /* actual */) ] An error type that used extensively as a failed result payload while decoding. let toString: t => string Formats the error as a string suitable for logging or showing to a user. let prependLocation: (t, locationComponent) => t Transforms the error by prepending a location component. Other details are kept intact. Use this function to rectify the error location while implementing custom codecs. Particularly, when you drill-down a Js.Json.t object manually and mix this with decoding through other codecs which know nothing about your drill-down.","title":"module Jzon.DecodingError"},{"location":"howtos/","text":"Jzon How-To Guides This document list common JSON coding tasks and how they could be solved with Jzon. How to encode/decode a record // The record to encode/decode type point = { x: float, y: float, z: float, color: string, } module Codecs = { // The codec for the record. There\u2019s no requirement to put it // into a sub-module, but groupping all the codecs with the same // names as their respective types in a dedicated module is // a good idea for code organization let point = Jzon.object4( ({x, y, z, color}) => (x, y, z, color), ((x, y, z, color)) => {x, y, z, color}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), Jzon.field(\"z\", Jzon.float), Jzon.field(\"color\", Jzon.string), ) } test(\"Record encoding\", () => { {x: 1.0, y: 2.0, z: 3.0, color: \"#fda\"} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}`) }) test(\"Record decoding\", () => { `{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 3.0, color: \"#fda\"})) // Missing some required fields `{\"x\":1,\"y\":2}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Error(#MissingField([], \"z\"))) }) How to make some fields optional Jzon supports two flavors of the optionality: fallback to a default value and lifting to option . In the first case you always get your value while decoding and don\u2019t even know whether the field was in JSON or not. And in the latter case you deal with None or Some(...) explicitly. The example below demonstrates both ways. type point = { x: float, y: float, z: float, color: option<string>, } module Codecs = { let point = Jzon.object4( ({x, y, z, color}) => (x, y, z, color), ((x, y, z, color)) => {x, y, z, color}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), // Use Jzon.default adapter to provide a fallback value in case // the field is missing Jzon.field(\"z\", Jzon.float)->Jzon.default(0.0), // Use Jzon.optional adapter to make the value indeed option\u2019al Jzon.field(\"color\", Jzon.string)->Jzon.optional, ) } test(\"Optional/default encoding\", () => { {x: 1.0, y: 2.0, z: 3.0, color: Some(\"#fda\")} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}`) // Optional fields are omitted in output if `None` and fields // with default values are always encoded, even if match the // fallback value {x: 1.0, y: 2.0, z: 0.0, color: None} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":0}`) }) test(\"Optional/default decoding\", () => { `{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 3.0, color: Some(\"#fda\")})) `{\"x\":1,\"y\":2}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 0.0, color: None})) }) How to encode/decode an opaque type Dealing with an opaque type is not much different from dealing with a record. You just use functions specific to the type to properly construct and destruct it. module Codecs = { let date = Jzon.object3( date => ( date->Js.Date.getUTCFullYear, date->Js.Date.getUTCMonth +. 1.0, date->Js.Date.getUTCDate, ), ((year, month, day)) => Js.Date.utcWithYMD(~year, ~month=month -. 1.0, ~date=day, ()) ->Js.Date.fromFloat ->Ok, Jzon.field(\"year\", Jzon.float), Jzon.field(\"month\", Jzon.float), Jzon.field(\"day\", Jzon.float), ) } test(\"Opaque type encoding\", () => { Js.Date.fromString(\"Thu, 29 Nov 1973 21:30:54.321 GMT\") ->Jzon.encodeStringWith(Codecs.date) ->Assert.equals(`{\"year\":1973,\"month\":11,\"day\":29}`) }) test(\"Opaque type decoding\", () => { `{\"year\":1973,\"month\":11,\"day\":29}` ->Jzon.decodeStringWith(Codecs.date) ->Assert.equals(Ok(Js.Date.fromString(\"Thu, 29 Nov 1973 00:00:00.000 GMT\"))) }) How to encode/decode array of records type point = { x: float, y: float, } type plot = { title: string, points: array<point>, } module Codecs = { let point = Jzon.object2( ({x, y}) => (x, y), ((x, y)) => {x, y}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), ) let plot = Jzon.object2( ({title, points}) => (title, points), ((title, points)) => {title, points}->Ok, Jzon.field(\"title\", Jzon.string), // Use the Jzon.array adapter to lift another codec to // a codec of an array Jzon.field(\"points\", Jzon.array(point)), ) } test(\"Array encoding\", () => { { title: \"My Plot\", points: [{x: 1.0, y: 2.0}, {x: 3.0, y: 4.0}, {x: 5.0, y: 6.0}], } ->Jzon.encodeStringWith(Codecs.plot) ->Assert.equals(`{\"title\":\"My Plot\",\"points\":[{\"x\":1,\"y\":2},{\"x\":3,\"y\":4},{\"x\":5,\"y\":6}]}`) }) test(\"Array decoding\", () => { `{ \"title\": \"My Plot\", \"points\": [ {\"x\":1, \"y\":2}, {\"x\":3, \"y\":4}, {\"x\":5, \"y\":6} ] }` ->Jzon.decodeStringWith(Codecs.plot) ->Assert.equals( Ok({ title: \"My Plot\", points: [{x: 1.0, y: 2.0}, {x: 3.0, y: 4.0}, {x: 5.0, y: 6.0}], }), ) // Missing field does not mean an empty array by default. However, you may use // the `default([])` field adaptor to express just that. `{\"title\": \"My Plot\"}` ->Jzon.decodeStringWith(Codecs.plot) ->Assert.equals(Error(#MissingField([], \"points\"))) }) How to express JSON shape dependent on a tag value Sometimes the JSON schema is dynamic and its particular subtree depends on a value of some tag field which is usually a string denoting some enum value. This scenario is perfectly OK for Jzon albeit requires some boilerplate code. Nested case You can face a JSON schema where the object field shape depends on the value of another field. For example: { \"kind\": \"circle\", \"geometry\": { \"r\": 15 } } // or { \"kind\": \"rectangle\", \"geometry\": { \"width\": 10, \"height\": 20 } } // or { \"kind\": \"ellipse\", \"geometry\": { \"width\": 30, \"height\": 40 } } In such case, the following codecs will do the job: type circle = {radius: float} type rectangle = { width: float, height: float, } type ellipse = { rx: float, ry: float, } // The type used to express various shapes type shape = | Circle(circle) | Rectangle(rectangle) | Ellipse(ellipse) module Codecs = { let circle = Jzon.object1( ({radius}) => radius, radius => {radius: radius}->Ok, Jzon.field(\"radius\", Jzon.float), ) let rectangle = Jzon.object2( ({width, height}) => (width, height), ((width, height)) => {width, height}->Ok, Jzon.field(\"width\", Jzon.float), Jzon.field(\"height\", Jzon.float), ) let ellipse = Jzon.object2( ({rx, ry}) => (rx, ry), ((rx, ry)) => {rx, ry}->Ok, Jzon.field(\"rx\", Jzon.float), Jzon.field(\"ry\", Jzon.float), ) let shape = Jzon.object2( shape => // Depending on the variant, stringify the tag for the \"kind\" field and // use appropriate codec for the geometry switch shape { | Circle(geo) => (\"circle\", geo->Jzon.encodeWith(circle)) | Rectangle(geo) => (\"rectangle\", geo->Jzon.encodeWith(rectangle)) | Ellipse(geo) => (\"ellipse\", geo->Jzon.encodeWith(ellipse)) }, ((kind, json)) => // Depending on the \"kind\" field value take a proper payload codec // and build the value in the ReScript world switch kind { | \"circle\" => json->Jzon.decodeWith(circle)->Result.map(geo => Circle(geo)) | \"rectangle\" => json->Jzon.decodeWith(rectangle)->Result.map(geo => Rectangle(geo)) | \"ellipse\" => json->Jzon.decodeWith(ellipse)->Result.map(geo => Ellipse(geo)) // Properly report bad enum value for pretty errors | x => Error(#UnexpectedJsonValue([Field(\"kind\")], x)) }, // The tag field is just an enum string Jzon.field(\"kind\", Jzon.string), // Pass the payload field as is for further processing Jzon.field(\"geometry\", Jzon.json), ) } test(\"Nested dependent schema encoding\", () => { Rectangle({width: 3.0, height: 4.0}) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"rectangle\",\"geometry\":{\"width\":3,\"height\":4}}`) Circle({radius: 15.0}) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"circle\",\"geometry\":{\"radius\":15}}`) }) test(\"Nested dependent schema decoding\", () => { `{\"kind\":\"rectangle\",\"geometry\":{\"width\":3,\"height\":4}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Rectangle({width: 3.0, height: 4.0}))) `{\"kind\":\"circle\",\"geometry\":{\"radius\":15}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Circle({radius: 15.0}))) `{\"kind\":\"donut\",\"geometry\":{\"radius\":15}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Error(#UnexpectedJsonValue([Field(\"kind\")], \"donut\"))) }) Flat case It might happen that the dependent fields are not encapsulated in a separate tree but smashed to the same JSON object: { \"kind\": \"circle\", \"r\": 15 } // or { \"kind\": \"rectangle\", \"width\": 10, \"height\": 20 } // or { \"kind\": \"ellipse\", \"width\": 30, \"height\": 40 } To make things worse, the ReScript representation might be arbitrary and not a record-per-variant. Nevertheless, this case is can be expressed and it\u2019s quite similar to the nested case: // The type used to express various shapes type shape = | Circle(float) | Rectangle(float, float) | Ellipse(float, float) module Codecs = { // Temporary codec for Circle params. Effectively a single field extractor. let radius = Jzon.object1( r => r, r => r->Ok, Jzon.field(\"r\", Jzon.float) ) // Temporary codec for Rectangle|Ellipse params. Effectively a converter // between JSON object and 2-tuple let widthHeight = Jzon.object2( ((w, h)) => (w, h), ((w, h)) => (w, h)->Ok, Jzon.field(\"width\", Jzon.float), Jzon.field(\"height\", Jzon.float), ) let shape = Jzon.object2( shape => // Depending on the variant, stringify the tag for the \"kind\" field and // use appropriate params codec for the rest fields switch shape { | Circle(r) => (\"circle\", r->Jzon.encodeWith(radius)) | Rectangle(width, height) => (\"rectangle\", (width, height)->Jzon.encodeWith(widthHeight)) | Ellipse(width, height) => (\"ellipse\", (width, height)->Jzon.encodeWith(widthHeight)) }, ((kind, json)) => // Depending on the \"kind\" field value take a proper params codec to decode // other fields and build the value in the ReScript world switch kind { | \"circle\" => json->Jzon.decodeWith(radius)->Result.map(r => Circle(r)) | \"rectangle\" => json->Jzon.decodeWith(widthHeight)->Result.map(((w, h)) => Rectangle(w, h)) | \"ellipse\" => json->Jzon.decodeWith(widthHeight)->Result.map(((w, h)) => Ellipse(w, h)) // Properly report bad enum value for pretty errors | x => Error(#UnexpectedJsonValue([Field(\"kind\")], x)) }, // The tag field is just an enum string Jzon.field(\"kind\", Jzon.string), // The `self` descriptor means \u201cthis object\u201d. It allows to further process the // same object with other codecs. Jzon.self, ) } test(\"Flat dependent schema encoding\", () => { Rectangle(3.0, 4.0) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"rectangle\",\"width\":3,\"height\":4}`) Circle(15.0) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"circle\",\"r\":15}`) }) test(\"Flat dependent schema decoding\", () => { `{\"kind\":\"rectangle\",\"width\":3,\"height\":4}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Rectangle(3.0, 4.0))) `{\"kind\":\"circle\",\"r\":15}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Circle(15.0))) `{\"kind\":\"donut\",\"r\":15}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Error(#UnexpectedJsonValue([Field(\"kind\")], \"donut\"))) })","title":"How-to Guides"},{"location":"howtos/#jzon-how-to-guides","text":"This document list common JSON coding tasks and how they could be solved with Jzon.","title":"Jzon How-To Guides"},{"location":"howtos/#how-to-encodedecode-a-record","text":"// The record to encode/decode type point = { x: float, y: float, z: float, color: string, } module Codecs = { // The codec for the record. There\u2019s no requirement to put it // into a sub-module, but groupping all the codecs with the same // names as their respective types in a dedicated module is // a good idea for code organization let point = Jzon.object4( ({x, y, z, color}) => (x, y, z, color), ((x, y, z, color)) => {x, y, z, color}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), Jzon.field(\"z\", Jzon.float), Jzon.field(\"color\", Jzon.string), ) } test(\"Record encoding\", () => { {x: 1.0, y: 2.0, z: 3.0, color: \"#fda\"} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}`) }) test(\"Record decoding\", () => { `{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 3.0, color: \"#fda\"})) // Missing some required fields `{\"x\":1,\"y\":2}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Error(#MissingField([], \"z\"))) })","title":"How to encode/decode a record"},{"location":"howtos/#how-to-make-some-fields-optional","text":"Jzon supports two flavors of the optionality: fallback to a default value and lifting to option . In the first case you always get your value while decoding and don\u2019t even know whether the field was in JSON or not. And in the latter case you deal with None or Some(...) explicitly. The example below demonstrates both ways. type point = { x: float, y: float, z: float, color: option<string>, } module Codecs = { let point = Jzon.object4( ({x, y, z, color}) => (x, y, z, color), ((x, y, z, color)) => {x, y, z, color}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), // Use Jzon.default adapter to provide a fallback value in case // the field is missing Jzon.field(\"z\", Jzon.float)->Jzon.default(0.0), // Use Jzon.optional adapter to make the value indeed option\u2019al Jzon.field(\"color\", Jzon.string)->Jzon.optional, ) } test(\"Optional/default encoding\", () => { {x: 1.0, y: 2.0, z: 3.0, color: Some(\"#fda\")} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}`) // Optional fields are omitted in output if `None` and fields // with default values are always encoded, even if match the // fallback value {x: 1.0, y: 2.0, z: 0.0, color: None} ->Jzon.encodeStringWith(Codecs.point) ->Assert.equals(`{\"x\":1,\"y\":2,\"z\":0}`) }) test(\"Optional/default decoding\", () => { `{\"x\":1,\"y\":2,\"z\":3,\"color\":\"#fda\"}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 3.0, color: Some(\"#fda\")})) `{\"x\":1,\"y\":2}` ->Jzon.decodeStringWith(Codecs.point) ->Assert.equals(Ok({x: 1.0, y: 2.0, z: 0.0, color: None})) })","title":"How to make some fields optional"},{"location":"howtos/#how-to-encodedecode-an-opaque-type","text":"Dealing with an opaque type is not much different from dealing with a record. You just use functions specific to the type to properly construct and destruct it. module Codecs = { let date = Jzon.object3( date => ( date->Js.Date.getUTCFullYear, date->Js.Date.getUTCMonth +. 1.0, date->Js.Date.getUTCDate, ), ((year, month, day)) => Js.Date.utcWithYMD(~year, ~month=month -. 1.0, ~date=day, ()) ->Js.Date.fromFloat ->Ok, Jzon.field(\"year\", Jzon.float), Jzon.field(\"month\", Jzon.float), Jzon.field(\"day\", Jzon.float), ) } test(\"Opaque type encoding\", () => { Js.Date.fromString(\"Thu, 29 Nov 1973 21:30:54.321 GMT\") ->Jzon.encodeStringWith(Codecs.date) ->Assert.equals(`{\"year\":1973,\"month\":11,\"day\":29}`) }) test(\"Opaque type decoding\", () => { `{\"year\":1973,\"month\":11,\"day\":29}` ->Jzon.decodeStringWith(Codecs.date) ->Assert.equals(Ok(Js.Date.fromString(\"Thu, 29 Nov 1973 00:00:00.000 GMT\"))) })","title":"How to encode/decode an opaque type"},{"location":"howtos/#how-to-encodedecode-array-of-records","text":"type point = { x: float, y: float, } type plot = { title: string, points: array<point>, } module Codecs = { let point = Jzon.object2( ({x, y}) => (x, y), ((x, y)) => {x, y}->Ok, Jzon.field(\"x\", Jzon.float), Jzon.field(\"y\", Jzon.float), ) let plot = Jzon.object2( ({title, points}) => (title, points), ((title, points)) => {title, points}->Ok, Jzon.field(\"title\", Jzon.string), // Use the Jzon.array adapter to lift another codec to // a codec of an array Jzon.field(\"points\", Jzon.array(point)), ) } test(\"Array encoding\", () => { { title: \"My Plot\", points: [{x: 1.0, y: 2.0}, {x: 3.0, y: 4.0}, {x: 5.0, y: 6.0}], } ->Jzon.encodeStringWith(Codecs.plot) ->Assert.equals(`{\"title\":\"My Plot\",\"points\":[{\"x\":1,\"y\":2},{\"x\":3,\"y\":4},{\"x\":5,\"y\":6}]}`) }) test(\"Array decoding\", () => { `{ \"title\": \"My Plot\", \"points\": [ {\"x\":1, \"y\":2}, {\"x\":3, \"y\":4}, {\"x\":5, \"y\":6} ] }` ->Jzon.decodeStringWith(Codecs.plot) ->Assert.equals( Ok({ title: \"My Plot\", points: [{x: 1.0, y: 2.0}, {x: 3.0, y: 4.0}, {x: 5.0, y: 6.0}], }), ) // Missing field does not mean an empty array by default. However, you may use // the `default([])` field adaptor to express just that. `{\"title\": \"My Plot\"}` ->Jzon.decodeStringWith(Codecs.plot) ->Assert.equals(Error(#MissingField([], \"points\"))) })","title":"How to encode/decode array of records"},{"location":"howtos/#how-to-express-json-shape-dependent-on-a-tag-value","text":"Sometimes the JSON schema is dynamic and its particular subtree depends on a value of some tag field which is usually a string denoting some enum value. This scenario is perfectly OK for Jzon albeit requires some boilerplate code.","title":"How to express JSON shape dependent on a tag value"},{"location":"howtos/#nested-case","text":"You can face a JSON schema where the object field shape depends on the value of another field. For example: { \"kind\": \"circle\", \"geometry\": { \"r\": 15 } } // or { \"kind\": \"rectangle\", \"geometry\": { \"width\": 10, \"height\": 20 } } // or { \"kind\": \"ellipse\", \"geometry\": { \"width\": 30, \"height\": 40 } } In such case, the following codecs will do the job: type circle = {radius: float} type rectangle = { width: float, height: float, } type ellipse = { rx: float, ry: float, } // The type used to express various shapes type shape = | Circle(circle) | Rectangle(rectangle) | Ellipse(ellipse) module Codecs = { let circle = Jzon.object1( ({radius}) => radius, radius => {radius: radius}->Ok, Jzon.field(\"radius\", Jzon.float), ) let rectangle = Jzon.object2( ({width, height}) => (width, height), ((width, height)) => {width, height}->Ok, Jzon.field(\"width\", Jzon.float), Jzon.field(\"height\", Jzon.float), ) let ellipse = Jzon.object2( ({rx, ry}) => (rx, ry), ((rx, ry)) => {rx, ry}->Ok, Jzon.field(\"rx\", Jzon.float), Jzon.field(\"ry\", Jzon.float), ) let shape = Jzon.object2( shape => // Depending on the variant, stringify the tag for the \"kind\" field and // use appropriate codec for the geometry switch shape { | Circle(geo) => (\"circle\", geo->Jzon.encodeWith(circle)) | Rectangle(geo) => (\"rectangle\", geo->Jzon.encodeWith(rectangle)) | Ellipse(geo) => (\"ellipse\", geo->Jzon.encodeWith(ellipse)) }, ((kind, json)) => // Depending on the \"kind\" field value take a proper payload codec // and build the value in the ReScript world switch kind { | \"circle\" => json->Jzon.decodeWith(circle)->Result.map(geo => Circle(geo)) | \"rectangle\" => json->Jzon.decodeWith(rectangle)->Result.map(geo => Rectangle(geo)) | \"ellipse\" => json->Jzon.decodeWith(ellipse)->Result.map(geo => Ellipse(geo)) // Properly report bad enum value for pretty errors | x => Error(#UnexpectedJsonValue([Field(\"kind\")], x)) }, // The tag field is just an enum string Jzon.field(\"kind\", Jzon.string), // Pass the payload field as is for further processing Jzon.field(\"geometry\", Jzon.json), ) } test(\"Nested dependent schema encoding\", () => { Rectangle({width: 3.0, height: 4.0}) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"rectangle\",\"geometry\":{\"width\":3,\"height\":4}}`) Circle({radius: 15.0}) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"circle\",\"geometry\":{\"radius\":15}}`) }) test(\"Nested dependent schema decoding\", () => { `{\"kind\":\"rectangle\",\"geometry\":{\"width\":3,\"height\":4}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Rectangle({width: 3.0, height: 4.0}))) `{\"kind\":\"circle\",\"geometry\":{\"radius\":15}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Circle({radius: 15.0}))) `{\"kind\":\"donut\",\"geometry\":{\"radius\":15}}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Error(#UnexpectedJsonValue([Field(\"kind\")], \"donut\"))) })","title":"Nested case"},{"location":"howtos/#flat-case","text":"It might happen that the dependent fields are not encapsulated in a separate tree but smashed to the same JSON object: { \"kind\": \"circle\", \"r\": 15 } // or { \"kind\": \"rectangle\", \"width\": 10, \"height\": 20 } // or { \"kind\": \"ellipse\", \"width\": 30, \"height\": 40 } To make things worse, the ReScript representation might be arbitrary and not a record-per-variant. Nevertheless, this case is can be expressed and it\u2019s quite similar to the nested case: // The type used to express various shapes type shape = | Circle(float) | Rectangle(float, float) | Ellipse(float, float) module Codecs = { // Temporary codec for Circle params. Effectively a single field extractor. let radius = Jzon.object1( r => r, r => r->Ok, Jzon.field(\"r\", Jzon.float) ) // Temporary codec for Rectangle|Ellipse params. Effectively a converter // between JSON object and 2-tuple let widthHeight = Jzon.object2( ((w, h)) => (w, h), ((w, h)) => (w, h)->Ok, Jzon.field(\"width\", Jzon.float), Jzon.field(\"height\", Jzon.float), ) let shape = Jzon.object2( shape => // Depending on the variant, stringify the tag for the \"kind\" field and // use appropriate params codec for the rest fields switch shape { | Circle(r) => (\"circle\", r->Jzon.encodeWith(radius)) | Rectangle(width, height) => (\"rectangle\", (width, height)->Jzon.encodeWith(widthHeight)) | Ellipse(width, height) => (\"ellipse\", (width, height)->Jzon.encodeWith(widthHeight)) }, ((kind, json)) => // Depending on the \"kind\" field value take a proper params codec to decode // other fields and build the value in the ReScript world switch kind { | \"circle\" => json->Jzon.decodeWith(radius)->Result.map(r => Circle(r)) | \"rectangle\" => json->Jzon.decodeWith(widthHeight)->Result.map(((w, h)) => Rectangle(w, h)) | \"ellipse\" => json->Jzon.decodeWith(widthHeight)->Result.map(((w, h)) => Ellipse(w, h)) // Properly report bad enum value for pretty errors | x => Error(#UnexpectedJsonValue([Field(\"kind\")], x)) }, // The tag field is just an enum string Jzon.field(\"kind\", Jzon.string), // The `self` descriptor means \u201cthis object\u201d. It allows to further process the // same object with other codecs. Jzon.self, ) } test(\"Flat dependent schema encoding\", () => { Rectangle(3.0, 4.0) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"rectangle\",\"width\":3,\"height\":4}`) Circle(15.0) ->Jzon.encodeStringWith(Codecs.shape) ->Assert.equals(`{\"kind\":\"circle\",\"r\":15}`) }) test(\"Flat dependent schema decoding\", () => { `{\"kind\":\"rectangle\",\"width\":3,\"height\":4}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Rectangle(3.0, 4.0))) `{\"kind\":\"circle\",\"r\":15}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Ok(Circle(15.0))) `{\"kind\":\"donut\",\"r\":15}` ->Jzon.decodeStringWith(Codecs.shape) ->Assert.equals(Error(#UnexpectedJsonValue([Field(\"kind\")], \"donut\"))) })","title":"Flat case"}]}